-- test error handling, i forgot to restore Warn_restart in
-- the trigger handler once. the errors and subsequent core dump were
-- interesting.
/* Flat out Python syntax error
 */
CREATE FUNCTION python_syntax_error() RETURNS text
        AS
'.syntaxerror'
        LANGUAGE plpythonu;
ERROR:  could not compile PL/Python function "python_syntax_error"
DETAIL:  SyntaxError: invalid syntax (line 2)
/* With check_function_bodies = false the function should get defined
 * and the error reported when called
 */
SET check_function_bodies = false;
CREATE FUNCTION python_syntax_error() RETURNS text
        AS
'.syntaxerror'
        LANGUAGE plpythonu;
SELECT python_syntax_error();
ERROR:  could not compile PL/Python function "python_syntax_error"
DETAIL:  SyntaxError: invalid syntax (line 2)
/* Run the function twice to check if the hashtable entry gets cleaned up */
SELECT python_syntax_error();
ERROR:  could not compile PL/Python function "python_syntax_error"
DETAIL:  SyntaxError: invalid syntax (line 2)
RESET check_function_bodies;
/* Flat out syntax error
 */
CREATE FUNCTION sql_syntax_error() RETURNS text
        AS
'plpy.execute("syntax error")'
        LANGUAGE plpythonu;
SELECT sql_syntax_error();
ERROR:  plpy.SPIError: syntax error at or near "syntax"
LINE 1: syntax error
        ^
QUERY:  syntax error
CONTEXT:  PL/Python function "sql_syntax_error"
/* check the handling of uncaught python exceptions
 */
CREATE FUNCTION exception_index_invalid(text) RETURNS text
	AS
'return args[1]'
	LANGUAGE plpythonu;
SELECT exception_index_invalid('test');
ERROR:  IndexError: list index out of range
CONTEXT:  PL/Python function "exception_index_invalid"
/* check handling of nested exceptions
 */
CREATE FUNCTION exception_index_invalid_nested() RETURNS text
	AS
'rv = plpy.execute("SELECT test5(''foo'')")
return rv[0]'
	LANGUAGE plpythonu;
SELECT exception_index_invalid_nested();
ERROR:  plpy.SPIError: function test5(unknown) does not exist
LINE 1: SELECT test5('foo')
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
QUERY:  SELECT test5('foo')
CONTEXT:  PL/Python function "exception_index_invalid_nested"
/* a typo
 */
CREATE FUNCTION invalid_type_uncaught(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	SD["plan"] = plpy.prepare(q, [ "test" ])
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_uncaught('rick');
ERROR:  plpy.SPIError: type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_uncaught"
/* for what it's worth catch the exception generated by
 * the typo, and return None
 */
CREATE FUNCTION invalid_type_caught(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	try:
		SD["plan"] = plpy.prepare(q, [ "test" ])
	except plpy.SPIError, ex:
		plpy.notice(str(ex))
		return None
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_caught('rick');
NOTICE:  type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_caught"
 invalid_type_caught 
---------------------
 
(1 row)

/* for what it's worth catch the exception generated by
 * the typo, and reraise it as a plain error
 */
CREATE FUNCTION invalid_type_reraised(a text) RETURNS text
	AS
'if "plan" not in SD:
	q = "SELECT fname FROM users WHERE lname = $1"
	try:
		SD["plan"] = plpy.prepare(q, [ "test" ])
	except plpy.SPIError, ex:
		plpy.error(str(ex))
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT invalid_type_reraised('rick');
ERROR:  plpy.Error: type "test" does not exist
CONTEXT:  PL/Python function "invalid_type_reraised"
/* no typo no messing about
 */
CREATE FUNCTION valid_type(a text) RETURNS text
	AS
'if "plan" not in SD:
	SD["plan"] = plpy.prepare("SELECT fname FROM users WHERE lname = $1", [ "text" ])
rv = plpy.execute(SD["plan"], [ a ])
if len(rv):
	return rv[0]["fname"]
return None
'
	LANGUAGE plpythonu;
SELECT valid_type('rick');
 valid_type 
------------
 
(1 row)

/* manually starting subtransactions - a bad idea
 */
CREATE FUNCTION manual_subxact() RETURNS void AS $$
plpy.execute("savepoint save")
plpy.execute("create table foo(x integer)")
plpy.execute("rollback to save")
$$ LANGUAGE plpythonu;
SELECT manual_subxact();
ERROR:  plpy.SPIError: SPI_execute failed: SPI_ERROR_TRANSACTION
CONTEXT:  PL/Python function "manual_subxact"
/* same for prepared plans
 */
CREATE FUNCTION manual_subxact_prepared() RETURNS void AS $$
save = plpy.prepare("savepoint save")
rollback = plpy.prepare("rollback to save")
plpy.execute(save)
plpy.execute("create table foo(x integer)")
plpy.execute(rollback)
$$ LANGUAGE plpythonu;
SELECT manual_subxact_prepared();
ERROR:  plpy.SPIError: SPI_execute_plan failed: SPI_ERROR_TRANSACTION
CONTEXT:  PL/Python function "manual_subxact_prepared"
